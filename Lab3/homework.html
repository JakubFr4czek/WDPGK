	<!doctype html>
	<html lang="en">
	<head>
		<title>Reflection (Three.js) Example 04 05</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel=stylesheet href="css/base.css"/>
	</head>
	<body>

	<script src="three.js"></script>
	<script src="ParametricGeometries.js"></script>
	<script src="CurveExtras.js"></script>
	<script src="Detector.js"></script>
	<script src="stats.js"></script>
	<script src="OrbitControls.js"></script>
	<script src="THREEx.KeyboardState.js"></script>
	<script src="THREEx.FullScreen.js"></script>
	<script src="THREEx.WindowResize.js"></script>

	<!-- jQuery code to display an information button and box when clicked. -->
	<script src="jquery-1.9.1.js"></script>
	<script src="jquery-ui.js"></script>
	<link rel=stylesheet href="jquery-ui.css" />
	<link rel=stylesheet href="info.css"/>
	<script src="info.js"></script>
	<div id="infoButton"></div>
	<div id="infoBox" title="Demo Information">
	This three.js demo is part of a collection at
	<a href="http://stemkoski.github.io/Three.js/">http://stemkoski.github.io/Three.js/</a>
	</div>
	<!-- ------------------------------------------------------------ -->

	<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
	<script>

	/*
		Mofified example from:

			Three.js "tutorials by example"
			Author: Lee Stemkoski
			Date: July 2013 (three.js v59dev)
		
	*/

	// MAIN

	// standard global variables
	var container, scene, camera, renderer, controls, stats;
	var keyboard = new THREEx.KeyboardState();
	var clock = new THREE.Clock();

	// custom global variables
	var mirrorSphere1, mirrorSphereCamera1;
	var mirrorSphere2, mirrorSphereCamera2;
	var spheres_pivot;

	var polyhedron1;

	init();
	animate();

	// FUNCTIONS 		
	function init() {

		// SCENE
		scene = new THREE.Scene();
		
		// CAMERA
		var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
		var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
		camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
		scene.add(camera);
		camera.position.set(0,150,400);
		camera.lookAt(scene.position);	

		// RENDERER
		if ( Detector.webgl )
			renderer = new THREE.WebGLRenderer( {antialias:true} );
		else
			renderer = new THREE.CanvasRenderer(); 
		renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
		container = document.getElementById( 'ThreeJS' );
		container.appendChild( renderer.domElement );
		
		// EVENTS
		THREEx.WindowResize(renderer, camera);
		THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
		
		// CONTROLS
		controls = new THREE.OrbitControls( camera, renderer.domElement );
		
		// STATS
		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.bottom = '0px';
		stats.domElement.style.zIndex = 100;
		container.appendChild( stats.domElement );
		
		// LIGHT
		var light = new THREE.PointLight(0xffffff);
		light.position.set(0,250,0);
		scene.add(light);
		
		// FLOOR
		/*
		var floorTexture = new THREE.TextureLoader().load( 'textures/stone.jpg' );
		floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
		floorTexture.repeat.set( 5, 5 );
		var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side:THREE.BackSide } );
		var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
		var floor = new THREE.Mesh(floorGeometry, floorMaterial);
		floor.position.y = -0.5;
		floor.rotation.x = Math.PI / 2;
		scene.add(floor);
		*/

		// SKYBOX/FOG
		var materialArray = [];
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'my_textures/px.png' ) }));
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'my_textures/nx.png' ) }));
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'my_textures/py.png' ) }));
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'my_textures/ny.png' ) }));
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'my_textures/pz.png' ) }));
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'my_textures/nz.png' ) }));
		for (var i = 0; i < 6; i++)
		materialArray[i].side = THREE.BackSide;
		var skyboxMaterial = new THREE.MeshFaceMaterial( materialArray );
		var skyboxGeom = new THREE.BoxGeometry( 5000, 5000, 5000, 64, 64, 64 );
		var skybox = new THREE.Mesh( skyboxGeom, skyboxMaterial );
		scene.add( skybox );	
		
		////////////
		// CUSTOM //
		////////////
		
		// ------ MIRROR SPHERES -------

		spheres_pivot = new THREE.Object3D();
		spheres_pivot.position.set(0, 0, 0);
		scene.add(spheres_pivot);

		// Mirror sphere 1
		mirrorSphereCamera1 = new THREE.CubeCamera( 0.1, 5000, 512 );
		spheres_pivot.add( mirrorSphereCamera1 );
		var sphereGeom =  new THREE.SphereGeometry( 50, 32, 16 );
		var mirrorSphereMaterial1 = new THREE.MeshBasicMaterial( { envMap: mirrorSphereCamera1.renderTarget } );
		mirrorSphere1 = new THREE.Mesh( sphereGeom, mirrorSphereMaterial1 );
		mirrorSphere1.position.set(-100,0,0);
		//mirrorSphereCamera.position = mirrorSphere.position;
		mirrorSphereCamera1.position.set(-100,0,0);
		spheres_pivot.add(mirrorSphere1);

		// Mirror sphere 2
		mirrorSphereCamera2 = new THREE.CubeCamera( 0.1, 5000, 512 );
		spheres_pivot.add( mirrorSphereCamera2 );
		var sphereGeom =  new THREE.SphereGeometry( 50, 32, 16 );
		var mirrorSphereMaterial2 = new THREE.MeshBasicMaterial( { envMap: mirrorSphereCamera2.renderTarget } );
		mirrorSphere2 = new THREE.Mesh( sphereGeom, mirrorSphereMaterial2 );
		mirrorSphere2.position.set(100,0,0);
		//mirrorSphereCamera.position = mirrorSphere.position;
		mirrorSphereCamera2.position.set(100,0,0);
		spheres_pivot.add(mirrorSphere2);

		// ------ DEFAULT ROCK ------
		polyhedron1 = createMesh(new THREE.IcosahedronGeometry(10, 0), "metal-rust.jpg");
        polyhedron1.position.x = 12;
        scene.add(polyhedron1);


	}

	function createMesh(geom, imageFile) {
            var texture = new THREE.TextureLoader().load("textures/" + imageFile);
			//var texture = THREE.ImageUtils.loadTexture("textures/" + imageFile)
			//texture.wrapS = THREE.RepeatWrapping; 
			//texture.wrapT = THREE.RepeatWrapping; 
			texture.repeat.set( 1, 1 );
            var mat = new THREE.MeshPhongMaterial();
            mat.map = texture;

            var mesh = new THREE.Mesh(geom, mat);
            return mesh;
    }

	function animate() {
		animate_objects();
		requestAnimationFrame( animate );
		render();		
		update();
	}

	function animate_objects(){
		spheres_pivot.rotation.y += 0.07;
		mirrorSphere1.rotation.x += 0.4;
		mirrorSphere2.rotation.z += 0.3;

		polyhedron1.rotation.x += 0.03
		polyhedron1.rotation.y += 0.04
	}

	function update()
	{
		if ( keyboard.pressed("z") ) 
		{ 
			// do something
		}
		
		controls.update();
		stats.update();
	}

	function render() 
	{
		// move the CubeCamera to the position of the object
		//    that has a reflective surface, "take a picture" in each direction
		//    and apply it to the surface.
		// need to hide surface before and after so that it does not
		//    "get in the way" of the camera

		mirrorSphere1.visible = false;
		mirrorSphereCamera1.updateCubeMap( renderer, scene );
		mirrorSphere1.visible = true;


		mirrorSphere2.visible = false;
		mirrorSphereCamera2.updateCubeMap( renderer, scene );
		mirrorSphere2.visible = true;

		//torus.visible = false;
		//mirrorTorusCamera.updateCubeMap( renderer, scene );
		//torus.visible = true;

		renderer.render( scene, camera );
	}

	</script>

	</body>
	</html>
